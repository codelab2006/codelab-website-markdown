# Java 虚拟机结构
> author: Yongjian Huang
> tags: Java

文章摘要
**********
## 运行时数据区
在一个 Java 程序运行时，Java 虚拟机会定义各种数据区给程序使用，有的数据区是供整个程序使用，在虚拟机启动时创建，在虚拟机退出时销毁。而有的数据区是供每个线程使用，在线程创建时创建，在线程退出时销毁。
### 程序计数器
Java 虚拟机支持多线程，每个线程用自己的程序计数器，如果当前线程执行的是非本地方法，则程序计数器包含当前正在执行的指令的地址。如果当前线程执行的是本地方法，则程序计数器的值为 undefined。
### 虚拟机栈
每个 Java 线程有自己的栈，在线程创建时进行分配。栈中存储的是 frames，当一个方法被调用时，将创建一个 frame，一个 frame 被用来存储局部变量表、操作数栈、动态链接、方法出口等信息。每个方法从调用直至完成的过程，都对应着一个栈帧从入栈到出栈的过程。每当一个方法执行完成时，该栈帧就会弹出栈帧的元素作为这个方法的返回值，并且清除这个栈帧，Java栈的栈顶的栈帧就是当前正在执行的活动栈，也就是当前正在执行的方法。就像是组成动画的一帧一帧的图片，方法的调用过程也是由栈帧切换来产生结果。
和栈相关的异常：
1. StackOverflowError 如果线程需要的栈空间大于虚拟机允许的栈空间。
2. OutOfMemoryError 当虚拟机栈可以动态扩展，但是可用内存不足以实现扩展。或者可用内存不足以为新的线程创建虚拟机栈。
### 本地方法栈
本地方法栈类似于虚拟机栈，虚拟机栈为 Java 方法服务，本地方法栈为 Native 方法服务。本地方法栈也会抛出StackOverflowError和OutOfMemoryError异常。
### 堆
堆被所有的线程分享，是一个运行时数据区，被用来存储类的实例。堆在虚拟机启动时创建，堆存储的对象会被 GC 自动回收。标准中没有明确规定 GC 如何实现，由实现这自己决定。堆可以是固定的大小，也可以是根据需求动态扩展，也可以进行收缩，堆的空间可以不是连续的。堆可以细分为：新生代和老年代。再细致一点可分为：Eden空间，From Survivor空间，To Survivor空间（空间分配比例是8：1：1）
和堆相关的异常：
1. OutOfMemoryError 如果程序运行中需要的堆超过了可用的堆。
### 方法区
方法区被所有的线程分享，存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据，也就是用来存储类的元数据的。方法区是堆的一个逻辑部分，为了区分 Java 堆，它还有一个别名 Non-Heap（非堆）。在 Java 8 之前，它还有个别名 “永久代“，确切的说应该是 “HotSpot 使用永久代实现了方法区”。从 Java 8 开始，“永久代” 已经被彻底移除，使用了一个元空间（Metaspace）来代替它。相对而言，GC对于这个区域的收集是很少出现的。
和方法区相关的异常：当方法区无法满足内存分配需求时，将抛出OutOfMemoryError异常。
